/* import java.util.NavigableMap;

public class lc1 {
    

    perm_equiv_permutation l1 l2 <-> l2 l1
    import list;
    import sorted;
    Include aritmetica;

    x: nat l

    fix point num_ocr
    se nil -> 0
    senao h::tail ->
    count = 0;
    if(x[count] == 1)
                        count++
                    else{
                        cont de NavigableMap
                    }


    teorema principal (10 pontos)
    //bala
    theorem perm_equiv: forall l l´, equiv l l´ < - > perm l l´l 
    proof;
    --prova duas direcoes da implicacao logica 
    -- split (12 pontos) equiv  (nao indutiva)-> perm_equ
    (6)
    perm (indutiva) -> equiv 
    - intro h introduction to induction (aplicar perm)

    PERM EQUAL REFLEXITY
    PERM SWAP (CASOS DE X0 E Y0)
    PERM N OCORRENCIAS (INDUZ QUE SAO IGUAIS ATRAVES DA REFLEXIDADE E PROVA COM INDUCAO)
    commmand 'simplesmente
    eqn:label salvar hipotese por label 
    PERM TRANS ()


    //alternativa 2 
    theorem Permutation_equiv: forall l l´, equiv l l´ < - > perm l l´l 
    proof;


    //outra parte falar de algoritmo
    bubble sort 
    




    eval compute in (num_oc 2 nill).compute
}
 */